//---------------------------------------------------------------------------
// File: packcage.cpp
// By:   SnipGhost
//                                                         Библиотека функций
//---------------------------------------------------------------------------
#include "packcage.h"
//---------------------------------------------------------------------------
// Ввод и проверка текста
//---------------------------------------------------------------------------
char* inputText()
{
	char *text = new char[MAX_TEXT_LEN], ch;
	int count = 0;
	do {	
		if (count >= MAX_TEXT_LEN-1) {
			cout << "\nПревышен максимальный размер текста\n";
			text[MAX_TEXT_LEN-1] = '\0';
			return text;
		}
		ch = getch(); // Ввод символов "налету" по нажатию клавиш
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Проверка введенного символа
		bool isLowerLatin = (ch >= 'a' && ch <= 'z');
		bool isUpperLatin = (ch >= 'A' && ch <= 'Z');
		bool isPunctMarks = (ch == ' ' || ch == ',' || ch == '.');
		if ( isLowerLatin || isUpperLatin || isPunctMarks)
			text[count++] = ch;
		else if (ch == END_OF_TEXT)
			text[count++] = '\0';
		else
			ch = BEEP_SYMBOL; // Аналогично: Beep(1000, 400);
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		cout << ch; // Выводим, чтобы пользователь видел, что он вводит
	} while (ch != END_OF_TEXT);
	return text;
}
//---------------------------------------------------------------------------
// Формирование текста
//---------------------------------------------------------------------------
Text* getText(const char *txt)
{
	if (txt == NULL) return NULL;
	Text *text = new Text;
	text->size = 1;
	const char *ptr = txt;
	while (*ptr != '\0')
	{
		if (*ptr == '.') text->size++;
		ptr++;
	}
	text->sent = new Sentence *[text->size];
	// TODO: В цикле делить txt на предложения с помощью strtok_s.
	//       Для каждого нового token вызывать getSentence(token),
	//       где char *token - одно предложение
	return text;
}
//---------------------------------------------------------------------------
Text::~Text()
{
	for (int i = 0; i < size; i++)
		delete [] sent[i];
	if (DEBUG) cout << "Текст удален" << endl;
}
//---------------------------------------------------------------------------
// Формирование педложения
//---------------------------------------------------------------------------
Sentence* getSentence(const char *txt)
{
	if (txt == NULL) return NULL;
	Sentence *sent = new Sentence;
	// TODO: Посчитать sent->size
	sent->word = new Word *[sent->size];
	// TODO: В цикле делить txt на слова с помощью strtok_s.
	//       Для каждого нового token вызывать getWord(token),
	//       где char *token - одно слово
	return sent;
}
//---------------------------------------------------------------------------
Sentence::~Sentence()
{
	// TODO: Очистить каждое слово от 0 до size-1
	if (DEBUG) cout << "Предложение удалено" << endl;
}
//---------------------------------------------------------------------------
// Формирование слова
//---------------------------------------------------------------------------
Word* getWord(const char *txt)
{
	if (txt == NULL) return NULL;
	Word *word = new Word;
	word->symbols = new char[strlen(txt)];
	strcpy(word->symbols, txt);
	return word;
}
//---------------------------------------------------------------------------
Word::~Word()
{
	delete [] symbols;
	if (DEBUG) cout << "Слово удалено" << endl;
}
//---------------------------------------------------------------------------
// Вспомогательная функция вывода
//---------------------------------------------------------------------------
void say(const char *msg)
{
	cout << msg << endl;
}
//---------------------------------------------------------------------------